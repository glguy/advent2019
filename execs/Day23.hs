{-# Language ImportQualifiedPost, DeriveTraversable #-}
{-|
Module      : Main
Description : Day 23 solution
Copyright   : (c) Eric Mertens, 2019
License     : ISC
Maintainer  : emertens@gmail.com

<https://adventofcode.com/2019/day/23>

-}
module Main (main) where

import Advent (getIntcodeInput)
import Advent.Queue (Queue(Empty, (:<|)), (|>), singleton)
import Control.Applicative ((<|>))
import Control.Monad.Trans.State.Strict (State, modify', runState)
import Data.IntMap (IntMap)
import Data.IntMap qualified as IntMap
import Data.List (group)
import Intcode (Effect(..), feedInput, run, new)

main :: IO ()
main =
  do inp <- getIntcodeInput 23
     let events = start (run (new inp))
     print (head     [y | SetNat y <- events])
     print (firstDup [y | Stall  y <- events])

data Packet = Packet !Int !Int !Int -- ^ destination, x, y

-- | Map of VM identities to current execution state.
type Network = IntMap Effect

data Event
  = SetNat Int -- ^ Y value of packet set to 255
  | Stall Int  -- ^ Y value of packet used to revive the network

-- | Given the program that runs on each machine, initialize it with its
-- network address and start the packet routing loop. Produce a list of
-- events generated by this network.
start :: Effect -> [Event]
start eff =
  let net0 = IntMap.fromList [(i, feedInput [i] eff) | i <- [0..49]] in
  case traverse gather net0 `runState` Empty of
    (net, ps) -> route net ps 0 0

------------------------------------------------------------------------

-- | Main network event loop that feeds the network packets from
-- its queue and automatically sends NAT wakeup packets when the
-- queue becomes empty to wake the network. All of the machines
-- stored in the network should be maintained in a stalled state.
route :: Network -> Queue Packet -> Int -> Int -> [Event]

route net Empty nx ny = Stall ny : route net (singleton (Packet 0 nx ny)) nx ny

route net (Packet i x y :<| ps) nx ny
  | 255 == i  = SetNat y : route net ps x y -- just remember this packet for later
  | otherwise = case ix i (gather . feedInput [x,y]) net `runState` ps of
                  (net', ps') -> route net' ps' nx ny

-- Packet output collection --------------------------------------------

-- | Trace a VM gathering all of its packets until it completely blocks
-- waiting for input.
gather :: Effect -> State (Queue Packet) Effect
gather e =
  case getPacket e <|> getPacket (feedInput [-1] e) of
    Just (p,e') -> do modify' (|> p); gather e'
    Nothing -> pure e

-- | Get a single packet if the machine is ready to send it.
getPacket :: Effect -> Maybe (Packet, Effect)
getPacket (Output dst (Output x (Output y e))) = Just (Packet dst x y, e)
getPacket _                                    = Nothing

-- Utility functions ---------------------------------------------------

firstDup :: Eq a => [a] -> a
firstDup ys = head [x | x:_:_ <- group ys]

-- | Run an applicative function on the element found at the given key if it's defined.
-- This is a specific case of @ix@ from the lens package.
ix :: Applicative f => Int -> (a -> f a) -> IntMap a -> f (IntMap a)
ix k f = IntMap.alterF (traverse f) k
