{-# Language ImportQualifiedPost, ViewPatterns #-}
{-|
Module      : Main
Description : Day 23 solution
Copyright   : (c) Eric Mertens, 2019
License     : ISC
Maintainer  : emertens@gmail.com

<https://adventofcode.com/2019/day/23>

-}
module Main (main) where

import Advent (getIntcodeInput)
import Advent.Queue (Queue(Empty, (:<|)), (|>), singleton)
import Control.Monad.Trans.State.Strict (State, modify', runState)
import Data.IntMap (IntMap)
import Data.IntMap qualified as IntMap
import Data.List (group)
import Intcode (Effect(..), feedInput, run, new)

main :: IO ()
main =
  do inp <- getIntcodeInput 23
     let events = start (run (new inp))
     print (head     [y | SetNat y <- events])
     print (firstDup [y | Stall  y <- events])

data Packet = Pkt !Int !Int !Int -- ^ destination, x, y

-- | Map of VM identities to current execution state.
type Network = IntMap Effect

data Event
  = SetNat !Int -- ^ Y value of packet set to 255
  | Stall  !Int -- ^ Y value of packet used to revive the network

-- | Given the program that runs on each machine, initialize it with its
-- network address and start the packet routing loop. Produce a list of
-- events generated by this network.
start :: Effect -> [Event]
start eff = routeState (traverse gather net) Empty 0 0
  where
    net = IntMap.fromList [(i, feedInput [i] eff) | i <- [0..49]]

------------------------------------------------------------------------

-- | Main network event loop that feeds the network packets from
-- its queue and automatically sends NAT wakeup packets when the
-- queue becomes empty to wake the network. All of the machines
-- stored in the network should be maintained in a stalled state.
route :: Network -> Queue Packet -> Int -> Int -> [Event]
route net Empty                x y = Stall  y : route net (singleton (Pkt 0 x y)) x y
route net (Pkt 255 x y :<| ps) _ _ = SetNat y : route net ps x y
route net (p           :<| ps) x y = routeState (deliver p net) ps x y

-- helper for running the packet queue through a stateful computation
-- that computes a new 'Network' while emitting packets.
routeState :: State (Queue Packet) Network -> Queue Packet -> Int -> Int -> [Event]
routeState m ps = uncurry route (runState m ps)

-- | Deliver a packet and then gather all the resulting outputs into the
-- send queue leaving that machine back in a stalled state.
deliver :: Packet -> Network -> State (Queue Packet) Network
deliver (Pkt i x y) = ix i (gather . feedInput [x,y])

-- | Get all the packets a machine is ready to send and add them to the
-- send queue. If the machine isn't quite ready try sending a @-1@.
gather :: Effect -> State (Queue Packet) Effect
gather (                  Output i (Output x (Output y e))) = modify' (|> Pkt i x y) >> gather e
gather (feedInput [-1] -> Output i (Output x (Output y e))) = modify' (|> Pkt i x y) >> gather e
gather e                                                    = pure e

-- Generic utility functions -------------------------------------------

-- | Find first duplicate, adjacent elements in a list
firstDup :: Eq a => [a] -> a
firstDup ys = head [x | x:_:_ <- group ys]

-- | Run an applicative function on the element found at the given key if it's defined.
-- This is a specific case of @ix@ from the lens package.
ix :: Applicative f => Int -> (a -> f a) -> IntMap a -> f (IntMap a)
ix k f = IntMap.alterF (traverse f) k
